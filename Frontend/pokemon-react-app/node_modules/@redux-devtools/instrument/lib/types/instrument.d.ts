import { Action, Reducer, Store, StoreEnhancer } from 'redux';
export declare const ActionTypes: {
    readonly PERFORM_ACTION: "PERFORM_ACTION";
    readonly RESET: "RESET";
    readonly ROLLBACK: "ROLLBACK";
    readonly COMMIT: "COMMIT";
    readonly SWEEP: "SWEEP";
    readonly TOGGLE_ACTION: "TOGGLE_ACTION";
    readonly SET_ACTIONS_ACTIVE: "SET_ACTIONS_ACTIVE";
    readonly JUMP_TO_STATE: "JUMP_TO_STATE";
    readonly JUMP_TO_ACTION: "JUMP_TO_ACTION";
    readonly REORDER_ACTION: "REORDER_ACTION";
    readonly IMPORT_STATE: "IMPORT_STATE";
    readonly LOCK_CHANGES: "LOCK_CHANGES";
    readonly PAUSE_RECORDING: "PAUSE_RECORDING";
};
export interface PerformAction<A extends Action<string>> {
    type: typeof ActionTypes.PERFORM_ACTION;
    action: A;
    timestamp: number;
    stack: string | undefined;
}
interface ResetAction {
    type: typeof ActionTypes.RESET;
    timestamp: number;
}
interface RollbackAction {
    type: typeof ActionTypes.ROLLBACK;
    timestamp: number;
}
interface CommitAction {
    type: typeof ActionTypes.COMMIT;
    timestamp: number;
}
interface SweepAction {
    type: typeof ActionTypes.SWEEP;
}
interface ToggleAction {
    type: typeof ActionTypes.TOGGLE_ACTION;
    id: number;
}
interface SetActionsActiveAction {
    type: typeof ActionTypes.SET_ACTIONS_ACTIVE;
    start: number;
    end: number;
    active: boolean;
}
interface ReorderAction {
    type: typeof ActionTypes.REORDER_ACTION;
    actionId: number;
    beforeActionId: number;
}
interface JumpToStateAction {
    type: typeof ActionTypes.JUMP_TO_STATE;
    index: number;
}
interface JumpToActionAction {
    type: typeof ActionTypes.JUMP_TO_ACTION;
    actionId: number;
}
interface ImportStateAction<S, A extends Action<string>, MonitorState> {
    type: typeof ActionTypes.IMPORT_STATE;
    nextLiftedState: LiftedState<S, A, MonitorState> | readonly A[];
    preloadedState?: S;
    noRecompute?: boolean | undefined;
}
interface LockChangesAction {
    type: typeof ActionTypes.LOCK_CHANGES;
    status: boolean;
}
interface PauseRecordingAction {
    type: typeof ActionTypes.PAUSE_RECORDING;
    status: boolean;
}
export type LiftedAction<S, A extends Action<string>, MonitorState> = PerformAction<A> | ResetAction | RollbackAction | CommitAction | SweepAction | ToggleAction | SetActionsActiveAction | ReorderAction | JumpToStateAction | JumpToActionAction | ImportStateAction<S, A, MonitorState> | LockChangesAction | PauseRecordingAction;
/**
 * Action creators to change the History state.
 */
export declare const ActionCreators: {
    performAction<A extends Action<string>>(action: A, trace?: boolean | ((action: A) => string | undefined) | undefined, traceLimit?: number, toExcludeFromTrace?: Function): {
        type: "PERFORM_ACTION";
        action: A;
        timestamp: number;
        stack: string | undefined;
    };
    reset(): ResetAction;
    rollback(): RollbackAction;
    commit(): CommitAction;
    sweep(): SweepAction;
    toggleAction(id: number): ToggleAction;
    setActionsActive(start: number, end: number, active?: boolean): SetActionsActiveAction;
    reorderAction(actionId: number, beforeActionId: number): ReorderAction;
    jumpToState(index: number): JumpToStateAction;
    jumpToAction(actionId: number): JumpToActionAction;
    importState<S, A_1 extends Action<string>, MonitorState = null>(nextLiftedState: LiftedState<S, A_1, MonitorState> | readonly A_1[], noRecompute?: boolean): ImportStateAction<S, A_1, MonitorState>;
    lockChanges(status: boolean): LockChangesAction;
    pauseRecording(status: boolean): PauseRecordingAction;
};
export declare const INIT_ACTION: {
    type: string;
};
export interface LiftedState<S, A extends Action<string>, MonitorState> {
    monitorState: MonitorState;
    nextActionId: number;
    actionsById: {
        [actionId: number]: PerformAction<A>;
    };
    stagedActionIds: number[];
    skippedActionIds: number[];
    committedState: S;
    currentStateIndex: number;
    computedStates: {
        state: S;
        error?: string;
    }[];
    isLocked: boolean;
    isPaused: boolean;
}
export type LiftedReducer<S, A extends Action<string>, MonitorState> = Reducer<LiftedState<S, A, MonitorState>, LiftedAction<S, A, MonitorState>>;
export type LiftedStore<S, A extends Action<string>, MonitorState> = Store<LiftedState<S, A, MonitorState>, LiftedAction<S, A, MonitorState>>;
export type InstrumentExt<S, A extends Action<string>, MonitorState> = {
    liftedStore: LiftedStore<S, A, MonitorState>;
};
export type EnhancedStore<S, A extends Action<string>, MonitorState> = Store<S, A> & InstrumentExt<S, A, MonitorState>;
export interface Options<S, A extends Action<string>, MonitorState, MonitorAction extends Action<string>> {
    maxAge?: number | ((currentLiftedAction: LiftedAction<S, A, MonitorState>, previousLiftedState: LiftedState<S, A, MonitorState> | undefined) => number);
    shouldCatchErrors?: boolean;
    shouldRecordChanges?: boolean;
    pauseActionType?: unknown;
    shouldStartLocked?: boolean;
    shouldHotReload?: boolean;
    trace?: boolean | ((action: A) => string | undefined);
    traceLimit?: number;
    shouldIncludeCallstack?: boolean;
}
/**
 * Redux instrumentation store enhancer.
 */
export declare function instrument<OptionsS, OptionsA extends Action<string>, MonitorState = null, MonitorAction extends Action<string> = never>(monitorReducer?: Reducer<MonitorState, MonitorAction>, options?: Options<OptionsS, OptionsA, MonitorState, MonitorAction>): StoreEnhancer<InstrumentExt<any, any, MonitorState>>;
export {};
